import { NextResponse } from 'next/server';
import dbConnect from '@/lib/db/connect';
import { Payment } from '@/lib/db/models/Payment';
import { Group } from '@/lib/db/models/Group';
import { GroupMember } from '@/lib/db/models/GroupMember';
import { verifyAuthToken } from '@/lib/utils/auth';

export async function POST(req: Request) {
  try {
    await dbConnect();
    const user = await verifyAuthToken(req);
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    const { type, id } = await req.json(); // type: 'group' | 'general'

    // --- CASE 1: GROUP EXPORT (Leader/Sub-leader Only) ---
    if (type === 'group' && id) {
      const group = await Group.findById(id);
      if (!group) return NextResponse.json({ error: 'Group not found' }, { status: 404 });

      // Verify Permission (Leader/Sub-leader only)
      const membership = await GroupMember.findOne({ userId: user._id, groupId: id });
      if (!membership || (membership.role !== 'leader' && membership.role !== 'sub_leader')) {
        return NextResponse.json({ error: 'Access denied. Leaders only.' }, { status: 403 });
      }

      // ✅ FIX: Populate 'memberId' to get Guest Names
      const payments = await Payment.find({ groupId: id })
        .populate('userId', 'name email') // Global User Data
        .populate('memberId', 'name')     // Group Snapshot Data (Critical for Guests)
        .sort({ cycleNumber: 1 });

      const exportData = payments.map(p => {
        let dateStr = '-';
        if (p.status === 'paid') {
           const d = p.paidDate || p.createdAt || new Date();
           dateStr = new Date(d).toLocaleDateString('en-IN');
        }

        // ✅ FIX: Smart Name Resolution
        // 1. Try Group Snapshot Name (memberId.name) - Works for Guests & Edited Members
        // 2. Try Global User Name (userId.name) - Fallback for Registered
        const memberName = p.memberId?.name || p.userId?.name || 'Unknown Member';

        const cycleNum = p.cycleNumber || 1;

        return {
          Cycle: `Cycle ${cycleNum}`,
          Member: memberName, // Now shows correct name for guests
          Amount: p.amount,
          Status: p.status.toUpperCase(),
          Date: dateStr,
          Method: p.paymentMethod || '-'
        };
      });

      return NextResponse.json({ 
        title: `${group.name} - Full Report`,
        meta: `Generated by ${user.name} on ${new Date().toLocaleDateString()}`,
        data: exportData 
      });
    }

    // --- CASE 2: GENERAL EXPORT (My Personal History - All Groups) ---
    if (type === 'general') {
      // Fetch ONLY my payments across all groups
      const myPayments = await Payment.find({ userId: user._id })
        .populate('groupId', 'name')
        .sort({ createdAt: -1 });

      const exportData = myPayments.map(p => {
        let dateStr = '-';
        if (p.status === 'paid') {
           const d = p.paidDate || p.createdAt || new Date();
           dateStr = new Date(d).toLocaleDateString('en-IN');
        }

        return {
          Group: p.groupId?.name || 'Deleted Group',
          Cycle: `Cycle ${p.cycleNumber || 1}`,
          Amount: p.amount,
          Status: p.status.toUpperCase(),
          Date: dateStr,
          Method: p.paymentMethod || '-'
        };
      });

      return NextResponse.json({ 
        title: `Personal Financial Report - ${user.name}`,
        meta: `Generated on ${new Date().toLocaleDateString()}`,
        data: exportData 
      });
    }

    return NextResponse.json({ error: 'Invalid export type' }, { status: 400 });

  } catch (error: any) {
    console.error('Export Error:', error);
    return NextResponse.json({ error: 'Export failed' }, { status: 500 });
  }
}